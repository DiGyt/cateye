<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cateye.visualization API documentation</title>
<meta name="description" content="cateye.visualization implements functions to plot and visualize classified
Eyetracking data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cateye.visualization</code></h1>
</header>
<section id="section-intro">
<p>cateye.visualization implements functions to plot and visualize classified
Eyetracking data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# (c) Dirk GÃ¼tlin, 2021. &lt;dirk.guetlin@gmail.com&gt;
#
# License: BSD-3-Clause

&#34;&#34;&#34;
cateye.visualization implements functions to plot and visualize classified 
Eyetracking data.
&#34;&#34;&#34;

import numpy as np
import nslr_hmm
import matplotlib.pyplot as plt

COLORS = {nslr_hmm.FIXATION: &#39;blue&#39;,
          nslr_hmm.SACCADE: &#39;black&#39;,
          nslr_hmm.SMOOTH_PURSUIT: &#39;green&#39;,
          nslr_hmm.PSO: &#39;yellow&#39;, }

N_COLS = {&#39;Fixation&#39;: &#39;blue&#39;,
          &#39;Saccade&#39;: &#39;black&#39;,
          &#39;ISaccade&#39;: &#39;gray&#39;,
          &#39;Smooth Pursuit&#39;: &#39;green&#39;,
          &#39;PSO&#39;: &#39;yellow&#39;,
          &#39;High-Velocity PSO&#39;: &#39;gold&#39;,
          &#39;Low-Velocity PSO&#39;: &#39;greenyellow&#39;,
          &#39;High-Velocity PSO (NCB)&#39;: &#39;goldenrod&#39;,
          &#39;Low-Velocity PSO (NCB)&#39;: &#39;yellowgreen&#39;,
          &#39;None&#39;:&#39;grey&#39;,}


def plot_segmentation(gaze, times, segments=None, events=None, show_event_text=True,
                      color_dict=None, show_legend=True, ax=None):
    &#34;&#34;&#34;Plots a gaze time series colored by discrete segments and annotated with 
    discrete events.
    
    Parameters
    ----------
    gaze : array of float
        A 1D-array representing one axis of the gaze data.
    times : array of float
        A 1D-array representing the sampling times of the gaze data. 
    segments : tuple of (array, array) or None
        Discrete segments as (segment_id, segment_value) as for 
        example created by `continuous_to_discrete` or 
        `classify_xy(return_discrete=true)`. The events defined in 
        segments will be used to color the plot line according to the 
        classes defined in segments. If None, segments will not be
        specifically colored. Default=None.
    events : tuple of (array, array) or None
        Discrete events as (event_id, event_value) as for example 
        created by `continuous_to_discrete` or 
        `classify_xy(return_discrete=true)`. The events defined in 
        events will be plotted as annotated vertical lines at the 
        respective time points. If None, no events will be annotated.
        Default=None.
    show_event_text : bool
        If True, plots events as vertical lines with text annotations 
        taken from events[1]. If False, plots only the vertical lines.
        Default=True.
    color_dict : dict or None
        A Dictionary mapping the set of keys in segments[1] to 
        matplotlib colors. This mapping will decide which segment 
        value will be plotted in which color. If None, a default 
        dict will be used, linking the default classification keys 
        (like &#34;Fixation&#34;, &#34;ISaccade&#34;, etc.) to CatEye standard colors. 
        Use this parameter if you want to change the standard colors 
        or if you want to color segments by keys which aren&#39;t listed 
        in the default dict. Default=None.
    show_legend : bool
        If True, plot a legend explaining segments according to 
        color_dict as well as events. Default=True.
    ax : matplotlib.pyplot.axes or None
        The matplotlib axis used to contain the plot. If None, a new
        plot will be created. Default=None.
        
    Returns
    -------
    ax : matplotlib.pyplot.axes
        The matplotlib plot.
    
    &#34;&#34;&#34;
    
    if ax == None:
        ax = plt.gca()
        
    if color_dict == None:
        color_dict = N_COLS
    
    if segments == None:
        ax.plot(times, gaze)
        
        # define the values for our legend
        color_dict = {&#34;Gaze&#34;:&#34;blue&#34;}
    else:
        # add multiple plot lines for each segment
        zip_seg = zip(segments[0][:-1], segments[0][1:], segments[1][:-1])
        for start, stop, cl in zip_seg:
            select = np.logical_and(times &gt;= start, times &lt;= stop)
            ax.plot(times[select], gaze[select], &#34;-&#34;, c=color_dict[cl])
        
        # define the values for our legend
        color_dict = {key:val for key, val in color_dict.items() if key in segments[1]}
        
    # define the leg artists
    leg_artists = [plt.Line2D((0,1),(0,0), color=color) for color in color_dict.values()]
    leg_indicators = list(color_dict.keys())
            
    if events != None:
        # add vertical bars at timepoints listed in events
        y_pos = ax.get_ylim()[0]
        x_pos = np.diff(ax.get_xlim()) / 200  # np.mean(times[1:] - times[:-1]) * 30
        for time, val in zip(events[0], events[1]):
            ax.axvline(x=float(time), linestyle=&#34;--&#34;)
            if show_event_text:
                ax.text(float(time) + x_pos, y_pos, f&#34; {val}&#34;, rotation=90,
                        verticalalignment=&#39;bottom&#39;, color=&#39;#1f77b4&#39;)
        
        # add legend artists for the events
        leg_artists = leg_artists + [plt.Line2D((0,1),(0,0),  linestyle=&#39;--&#39;, color=&#39;#1f77b4&#39;)]
        leg_indicators = leg_indicators + [&#34;Events&#34;]
        
        
    if show_legend:
        ax.legend(leg_artists, leg_indicators, loc=&#34;lower right&#34;)
                
    return ax


def plot_trajectory(x, y, times, segments=None, color_dict=None, show_legend=True,
                    show_clean=True, show_arrows=True, show_dots=False, alpha_decay=0.,
                    ax=None, plot_kwargs={}, dot_kwargs={}, arrow_kwargs={}):
    &#34;&#34;&#34;Plots a spatial gaze trajectory colored by discrete segments, e.g. according to
    gaze classification.
        
    Parameters
    ----------
    x : array of float
        A 1D-array representing the x-axis of the gaze data.
    y : array of float
        A 1D-array representing the y-axis of the gaze data.
    times : array of float
        A 1D-array representing the sampling times of the gaze data. 
    segments : tuple of (array, array) or None
        Discrete segments as (segment_id, segment_value) as for 
        example created by `continuous_to_discrete` or 
        `classify_xy(return_discrete=true)`. The events defined in 
        segments will be used to color the plot line according to the 
        classes defined in segments. If None, segments will not be
        specifically colored. Default=None.
    color_dict : dict or None
        A Dictionary mapping the set of keys in segments[1] to 
        matplotlib colors. This mapping will decide which segment 
        value will be plotted in which color. If None, a default 
        dict will be used, linking the default classification keys 
        (like &#34;Fixation&#34;, &#34;ISaccade&#34;, etc.) to CatEye standard colors. 
        Use this parameter if you want to change the standard colors 
        or if you want to color segments by keys which aren&#39;t listed 
        in the default dict. Default=None.
    show_legend : bool
        If True, plot a legend explaining segments according to 
        color_dict as well as events. Default=True.
    show_clean : bool
        If True, simplify the gaze plot by reducing Fixation and 
        Saccade segments as straight lines instead of the original 
        sample course. Default=True.
    show_arrows : bool
        If True, plot Saccades as arrows indicating the Saccade 
        direction instead of lines/the original sample course.
        If True, show_clean must also be True. Default=True.
    show_dots : bool
        If True, Indicate the start of each new segment with a 
        plotted dot, colored in the segment color. Default=False.
    alpha_decay : float
        With this parameter, the alpha level of each segment can 
        be decayed such that newer segments are more visible and 
        older segments are less visible. Starting with the latest
        segment, each earler segment&#39;s alpha level will be decayed
        by alpha_decay. Default=0.
    ax : matplotlib.pyplot.axes or None
        The matplotlib axis used to contain the plot. If None, a new
        plot will be created. Default=None.
    plot_kwargs : dict
        A dict consisting of keys that can be fed as keyword arguments 
        to plt.plot() when plotting the gaze course. Can be used to 
        embellish the plot. Default={}.
    dot_kwargs : dict
        A dict consisting of keys that can be fed as keyword arguments 
        to plt.plot() when plotting the segment dots. Default={}.
    arrow_kwargs : dict
        A dict consisting of keys that can be fed as keyword arguments 
        to plt.arrow() when plotting the Saccade arrows. Default={}.
        
    Returns
    -------
    ax : matplotlib.pyplot.axes
        The matplotlib plot.
        &#34;&#34;&#34;
    
    if show_arrows == True and show_clean == False:
        raise ValueError(&#34;If show_arrows = True, then show_clean must be True.&#34;)
    
    if &#34;marker&#34; not in dot_kwargs.keys():
        dot_kwargs[&#34;marker&#34;] = &#34;.&#34;
    if &#34;head_width&#34; not in arrow_kwargs.keys():
        arrow_kwargs[&#34;head_width&#34;] = 0.1
    
    if ax == None:
        ax = plt.gca()
        
    if color_dict == None:
        color_dict = N_COLS
    
    if segments == None:
        ax.plot(x, y, **plot_kwargs)
        
        # define the values for our legend
        color_dict = {&#34;Gaze&#34;:&#34;blue&#34;}
    else:
        # add multiple plot lines for each segment
        zip_seg = zip(segments[0][:-1], segments[0][1:], segments[1][:-1])
        alpha = 1
        for start, stop, cl in reversed(list(zip_seg)):
            select = np.logical_and(times &gt;= start, times &lt;= stop)
            x_sel = x[select]
            y_sel = y[select]
            if show_clean and cl in [&#39;Fixation&#39;, &#39;Saccade&#39;, &#39;ISaccade&#39;] and len(x_sel) &gt; 0:
                if show_arrows and cl in [&#39;Saccade&#39;, &#39;ISaccade&#39;]:
                    ax.arrow(x_sel[0], y_sel[0], x_sel[-1] - x_sel[0], y_sel[-1] - y_sel[0],
                             color=color_dict[cl], length_includes_head=True, alpha=alpha,
                             **arrow_kwargs)
                else:
                    ax.plot([x_sel[0], x_sel[-1]], [y_sel[0], y_sel[-1]],
                            c=color_dict[cl], alpha=alpha, **plot_kwargs)
            else:
                ax.plot(x_sel, y_sel, c=color_dict[cl], alpha=alpha, **plot_kwargs)
                
            if show_dots and len(x_sel) &gt; 0:
                ax.plot(x_sel[-1], y_sel[-1], c=color_dict[cl], alpha=alpha, **dot_kwargs)
            if len(x_sel) &gt; 0:
                alpha -= alpha_decay
        
        # define the values for our legend
        color_dict = {key:val for key, val in color_dict.items() if key in segments[1]}
       
    # define legend artists
    leg_artists = [plt.Line2D((0,1),(0,0), color=color) for color in color_dict.values()]
    leg_indicators = list(color_dict.keys())
          
    if show_legend:
        ax.legend(leg_artists, leg_indicators)
                
    return ax


def plot_nslr_segmentation(time_array, gaze_array, segmentation, seg_class, trial_info=None,
                           title=None, stimulus=None, figsize=None, blinks=None):
    &#34;&#34;&#34;Plots a segmentation using NSLR&#39;s original segmentation (including smoothing). Not
    intended for general use.
    &#34;&#34;&#34;
    VAR_NAMES = [&#34;Theta&#34;, &#34;Phi&#34;]
    
    f, axes = plt.subplots(2, 1, sharex=True, figsize=figsize)
    f.subplots_adjust(hspace=0)
    f.suptitle(title)  # , fontsize=16)

    # the limits are defined as 2 std devs from mean
    y_lims = np.array(gaze_array).std(axis=0) * 2

    for idx, ax in enumerate(axes):

        # construct a plotting frame
        ax.set_ylabel(VAR_NAMES[idx] + &#34;: Rot. in degrees&#34;)
        ax.set_ylim([-y_lims[idx], y_lims[idx]])
        ax.axhline(y=0, color=&#34;lightgray&#34;, linestyle=&#34;--&#34;)
        ax.axhline(y=-20, color=&#34;lightgray&#34;, linestyle=&#34;--&#34;)
        ax.axhline(y=20, color=&#34;lightgray&#34;, linestyle=&#34;--&#34;)


        ax.plot(time_array, gaze_array[:,idx], &#39;.&#39;)
        if not isinstance(stimulus, type(None)):
            st_id = [&#34;X_Position&#34;, &#34;Y_Position&#34;]
            ax.plot(stimulus[&#34;Timestamp&#34;].to_numpy(), stimulus[st_id[idx]].to_numpy(), &#34;--&#34;, color=&#34;lightblue&#34;)

        for i, seg in enumerate(segmentation.segments):
            cls = seg_class[i]
            if (seg.t[0] &gt; time_array[0]) and (seg.t[1] &lt; time_array[-1]): 
                ax.plot(seg.t, np.array(seg.x)[:, idx], color=COLORS[cls])

    if trial_info != None and len(trial_info) &gt; 0:
        y_pos = - y_lims[1] * 0.95  # min([i[0] for i in gaze_array])
        x_pos = (time_array[-1] - time_array[1]) / 150

        for key in trial_info:
            axes[0].axvline(x=float(key), linestyle=&#34;--&#34;)
            axes[1].axvline(x=float(key), linestyle=&#34;--&#34;)
            axes[1].text(float(key) + x_pos, y_pos,
                         &#34;Event: {}&#34;.format(trial_info[key]), rotation=90,
                         verticalalignment=&#39;bottom&#39;, color=&#39;#1f77b4&#39;)  #, weight=&#34;bold&#34;)

    
    leg_artists = [plt.Line2D((0,1),(0,0), marker=&#39;.&#39;, linestyle=&#39;&#39;)] + \
                  [plt.Line2D((0,1),(0,0), color=color) for color in COLORS.values()]
    leg_indicators = [&#34;Orig. Samples&#34;, &#34;Fixation&#34;, &#34;Saccade&#34;, &#34;Smooth Pursuit&#34;, &#34;PSO&#34;]
    plt.legend(leg_artists, leg_indicators, loc=&#34;lower right&#34;, title=&#34;Gaze Classification&#34;)
    
        
    if not isinstance(stimulus, type(None)):
        leg_artists = leg_artists + [plt.Line2D((0,1),(0,0),  linestyle=&#39;--&#39;, color=&#34;lightblue&#34;)]
        leg_indicators = leg_indicators + [&#34;Stimulus data&#34;]
        
    plt.legend(leg_artists, leg_indicators, loc=&#34;lower right&#34;, title=&#34;Gaze Classification&#34;)
    plt.xlabel(&#34;Time in seconds&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cateye.visualization.plot_segmentation"><code class="name flex">
<span>def <span class="ident">plot_segmentation</span></span>(<span>gaze, times, segments=None, events=None, show_event_text=True, color_dict=None, show_legend=True, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a gaze time series colored by discrete segments and annotated with
discrete events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gaze</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>A 1D-array representing one axis of the gaze data.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>A 1D-array representing the sampling times of the gaze data.</dd>
<dt><strong><code>segments</code></strong> :&ensp;<code>tuple</code> of <code>(array, array)</code> or <code>None</code></dt>
<dd>Discrete segments as (segment_id, segment_value) as for
example created by <code>continuous_to_discrete</code> or
<code>classify_xy(return_discrete=true)</code>. The events defined in
segments will be used to color the plot line according to the
classes defined in segments. If None, segments will not be
specifically colored. Default=None.</dd>
<dt><strong><code>events</code></strong> :&ensp;<code>tuple</code> of <code>(array, array)</code> or <code>None</code></dt>
<dd>Discrete events as (event_id, event_value) as for example
created by <code>continuous_to_discrete</code> or
<code>classify_xy(return_discrete=true)</code>. The events defined in
events will be plotted as annotated vertical lines at the
respective time points. If None, no events will be annotated.
Default=None.</dd>
<dt><strong><code>show_event_text</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plots events as vertical lines with text annotations
taken from events[1]. If False, plots only the vertical lines.
Default=True.</dd>
<dt><strong><code>color_dict</code></strong> :&ensp;<code>dict</code> or <code>None</code></dt>
<dd>A Dictionary mapping the set of keys in segments[1] to
matplotlib colors. This mapping will decide which segment
value will be plotted in which color. If None, a default
dict will be used, linking the default classification keys
(like "Fixation", "ISaccade", etc.) to CatEye standard colors.
Use this parameter if you want to change the standard colors
or if you want to color segments by keys which aren't listed
in the default dict. Default=None.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plot a legend explaining segments according to
color_dict as well as events. Default=True.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axes</code> or <code>None</code></dt>
<dd>The matplotlib axis used to contain the plot. If None, a new
plot will be created. Default=None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axes</code></dt>
<dd>The matplotlib plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_segmentation(gaze, times, segments=None, events=None, show_event_text=True,
                      color_dict=None, show_legend=True, ax=None):
    &#34;&#34;&#34;Plots a gaze time series colored by discrete segments and annotated with 
    discrete events.
    
    Parameters
    ----------
    gaze : array of float
        A 1D-array representing one axis of the gaze data.
    times : array of float
        A 1D-array representing the sampling times of the gaze data. 
    segments : tuple of (array, array) or None
        Discrete segments as (segment_id, segment_value) as for 
        example created by `continuous_to_discrete` or 
        `classify_xy(return_discrete=true)`. The events defined in 
        segments will be used to color the plot line according to the 
        classes defined in segments. If None, segments will not be
        specifically colored. Default=None.
    events : tuple of (array, array) or None
        Discrete events as (event_id, event_value) as for example 
        created by `continuous_to_discrete` or 
        `classify_xy(return_discrete=true)`. The events defined in 
        events will be plotted as annotated vertical lines at the 
        respective time points. If None, no events will be annotated.
        Default=None.
    show_event_text : bool
        If True, plots events as vertical lines with text annotations 
        taken from events[1]. If False, plots only the vertical lines.
        Default=True.
    color_dict : dict or None
        A Dictionary mapping the set of keys in segments[1] to 
        matplotlib colors. This mapping will decide which segment 
        value will be plotted in which color. If None, a default 
        dict will be used, linking the default classification keys 
        (like &#34;Fixation&#34;, &#34;ISaccade&#34;, etc.) to CatEye standard colors. 
        Use this parameter if you want to change the standard colors 
        or if you want to color segments by keys which aren&#39;t listed 
        in the default dict. Default=None.
    show_legend : bool
        If True, plot a legend explaining segments according to 
        color_dict as well as events. Default=True.
    ax : matplotlib.pyplot.axes or None
        The matplotlib axis used to contain the plot. If None, a new
        plot will be created. Default=None.
        
    Returns
    -------
    ax : matplotlib.pyplot.axes
        The matplotlib plot.
    
    &#34;&#34;&#34;
    
    if ax == None:
        ax = plt.gca()
        
    if color_dict == None:
        color_dict = N_COLS
    
    if segments == None:
        ax.plot(times, gaze)
        
        # define the values for our legend
        color_dict = {&#34;Gaze&#34;:&#34;blue&#34;}
    else:
        # add multiple plot lines for each segment
        zip_seg = zip(segments[0][:-1], segments[0][1:], segments[1][:-1])
        for start, stop, cl in zip_seg:
            select = np.logical_and(times &gt;= start, times &lt;= stop)
            ax.plot(times[select], gaze[select], &#34;-&#34;, c=color_dict[cl])
        
        # define the values for our legend
        color_dict = {key:val for key, val in color_dict.items() if key in segments[1]}
        
    # define the leg artists
    leg_artists = [plt.Line2D((0,1),(0,0), color=color) for color in color_dict.values()]
    leg_indicators = list(color_dict.keys())
            
    if events != None:
        # add vertical bars at timepoints listed in events
        y_pos = ax.get_ylim()[0]
        x_pos = np.diff(ax.get_xlim()) / 200  # np.mean(times[1:] - times[:-1]) * 30
        for time, val in zip(events[0], events[1]):
            ax.axvline(x=float(time), linestyle=&#34;--&#34;)
            if show_event_text:
                ax.text(float(time) + x_pos, y_pos, f&#34; {val}&#34;, rotation=90,
                        verticalalignment=&#39;bottom&#39;, color=&#39;#1f77b4&#39;)
        
        # add legend artists for the events
        leg_artists = leg_artists + [plt.Line2D((0,1),(0,0),  linestyle=&#39;--&#39;, color=&#39;#1f77b4&#39;)]
        leg_indicators = leg_indicators + [&#34;Events&#34;]
        
        
    if show_legend:
        ax.legend(leg_artists, leg_indicators, loc=&#34;lower right&#34;)
                
    return ax</code></pre>
</details>
</dd>
<dt id="cateye.visualization.plot_trajectory"><code class="name flex">
<span>def <span class="ident">plot_trajectory</span></span>(<span>x, y, times, segments=None, color_dict=None, show_legend=True, show_clean=True, show_arrows=True, show_dots=False, alpha_decay=0.0, ax=None, plot_kwargs={}, dot_kwargs={}, arrow_kwargs={})</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a spatial gaze trajectory colored by discrete segments, e.g. according to
gaze classification.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>A 1D-array representing the x-axis of the gaze data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>A 1D-array representing the y-axis of the gaze data.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>A 1D-array representing the sampling times of the gaze data.</dd>
<dt><strong><code>segments</code></strong> :&ensp;<code>tuple</code> of <code>(array, array)</code> or <code>None</code></dt>
<dd>Discrete segments as (segment_id, segment_value) as for
example created by <code>continuous_to_discrete</code> or
<code>classify_xy(return_discrete=true)</code>. The events defined in
segments will be used to color the plot line according to the
classes defined in segments. If None, segments will not be
specifically colored. Default=None.</dd>
<dt><strong><code>color_dict</code></strong> :&ensp;<code>dict</code> or <code>None</code></dt>
<dd>A Dictionary mapping the set of keys in segments[1] to
matplotlib colors. This mapping will decide which segment
value will be plotted in which color. If None, a default
dict will be used, linking the default classification keys
(like "Fixation", "ISaccade", etc.) to CatEye standard colors.
Use this parameter if you want to change the standard colors
or if you want to color segments by keys which aren't listed
in the default dict. Default=None.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plot a legend explaining segments according to
color_dict as well as events. Default=True.</dd>
<dt><strong><code>show_clean</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, simplify the gaze plot by reducing Fixation and
Saccade segments as straight lines instead of the original
sample course. Default=True.</dd>
<dt><strong><code>show_arrows</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plot Saccades as arrows indicating the Saccade
direction instead of lines/the original sample course.
If True, show_clean must also be True. Default=True.</dd>
<dt><strong><code>show_dots</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, Indicate the start of each new segment with a
plotted dot, colored in the segment color. Default=False.</dd>
<dt><strong><code>alpha_decay</code></strong> :&ensp;<code>float</code></dt>
<dd>With this parameter, the alpha level of each segment can
be decayed such that newer segments are more visible and
older segments are less visible. Starting with the latest
segment, each earler segment's alpha level will be decayed
by alpha_decay. Default=0.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axes</code> or <code>None</code></dt>
<dd>The matplotlib axis used to contain the plot. If None, a new
plot will be created. Default=None.</dd>
<dt><strong><code>plot_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dict consisting of keys that can be fed as keyword arguments
to plt.plot() when plotting the gaze course. Can be used to
embellish the plot. Default={}.</dd>
<dt><strong><code>dot_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dict consisting of keys that can be fed as keyword arguments
to plt.plot() when plotting the segment dots. Default={}.</dd>
<dt><strong><code>arrow_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dict consisting of keys that can be fed as keyword arguments
to plt.arrow() when plotting the Saccade arrows. Default={}.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axes</code></dt>
<dd>The matplotlib plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_trajectory(x, y, times, segments=None, color_dict=None, show_legend=True,
                    show_clean=True, show_arrows=True, show_dots=False, alpha_decay=0.,
                    ax=None, plot_kwargs={}, dot_kwargs={}, arrow_kwargs={}):
    &#34;&#34;&#34;Plots a spatial gaze trajectory colored by discrete segments, e.g. according to
    gaze classification.
        
    Parameters
    ----------
    x : array of float
        A 1D-array representing the x-axis of the gaze data.
    y : array of float
        A 1D-array representing the y-axis of the gaze data.
    times : array of float
        A 1D-array representing the sampling times of the gaze data. 
    segments : tuple of (array, array) or None
        Discrete segments as (segment_id, segment_value) as for 
        example created by `continuous_to_discrete` or 
        `classify_xy(return_discrete=true)`. The events defined in 
        segments will be used to color the plot line according to the 
        classes defined in segments. If None, segments will not be
        specifically colored. Default=None.
    color_dict : dict or None
        A Dictionary mapping the set of keys in segments[1] to 
        matplotlib colors. This mapping will decide which segment 
        value will be plotted in which color. If None, a default 
        dict will be used, linking the default classification keys 
        (like &#34;Fixation&#34;, &#34;ISaccade&#34;, etc.) to CatEye standard colors. 
        Use this parameter if you want to change the standard colors 
        or if you want to color segments by keys which aren&#39;t listed 
        in the default dict. Default=None.
    show_legend : bool
        If True, plot a legend explaining segments according to 
        color_dict as well as events. Default=True.
    show_clean : bool
        If True, simplify the gaze plot by reducing Fixation and 
        Saccade segments as straight lines instead of the original 
        sample course. Default=True.
    show_arrows : bool
        If True, plot Saccades as arrows indicating the Saccade 
        direction instead of lines/the original sample course.
        If True, show_clean must also be True. Default=True.
    show_dots : bool
        If True, Indicate the start of each new segment with a 
        plotted dot, colored in the segment color. Default=False.
    alpha_decay : float
        With this parameter, the alpha level of each segment can 
        be decayed such that newer segments are more visible and 
        older segments are less visible. Starting with the latest
        segment, each earler segment&#39;s alpha level will be decayed
        by alpha_decay. Default=0.
    ax : matplotlib.pyplot.axes or None
        The matplotlib axis used to contain the plot. If None, a new
        plot will be created. Default=None.
    plot_kwargs : dict
        A dict consisting of keys that can be fed as keyword arguments 
        to plt.plot() when plotting the gaze course. Can be used to 
        embellish the plot. Default={}.
    dot_kwargs : dict
        A dict consisting of keys that can be fed as keyword arguments 
        to plt.plot() when plotting the segment dots. Default={}.
    arrow_kwargs : dict
        A dict consisting of keys that can be fed as keyword arguments 
        to plt.arrow() when plotting the Saccade arrows. Default={}.
        
    Returns
    -------
    ax : matplotlib.pyplot.axes
        The matplotlib plot.
        &#34;&#34;&#34;
    
    if show_arrows == True and show_clean == False:
        raise ValueError(&#34;If show_arrows = True, then show_clean must be True.&#34;)
    
    if &#34;marker&#34; not in dot_kwargs.keys():
        dot_kwargs[&#34;marker&#34;] = &#34;.&#34;
    if &#34;head_width&#34; not in arrow_kwargs.keys():
        arrow_kwargs[&#34;head_width&#34;] = 0.1
    
    if ax == None:
        ax = plt.gca()
        
    if color_dict == None:
        color_dict = N_COLS
    
    if segments == None:
        ax.plot(x, y, **plot_kwargs)
        
        # define the values for our legend
        color_dict = {&#34;Gaze&#34;:&#34;blue&#34;}
    else:
        # add multiple plot lines for each segment
        zip_seg = zip(segments[0][:-1], segments[0][1:], segments[1][:-1])
        alpha = 1
        for start, stop, cl in reversed(list(zip_seg)):
            select = np.logical_and(times &gt;= start, times &lt;= stop)
            x_sel = x[select]
            y_sel = y[select]
            if show_clean and cl in [&#39;Fixation&#39;, &#39;Saccade&#39;, &#39;ISaccade&#39;] and len(x_sel) &gt; 0:
                if show_arrows and cl in [&#39;Saccade&#39;, &#39;ISaccade&#39;]:
                    ax.arrow(x_sel[0], y_sel[0], x_sel[-1] - x_sel[0], y_sel[-1] - y_sel[0],
                             color=color_dict[cl], length_includes_head=True, alpha=alpha,
                             **arrow_kwargs)
                else:
                    ax.plot([x_sel[0], x_sel[-1]], [y_sel[0], y_sel[-1]],
                            c=color_dict[cl], alpha=alpha, **plot_kwargs)
            else:
                ax.plot(x_sel, y_sel, c=color_dict[cl], alpha=alpha, **plot_kwargs)
                
            if show_dots and len(x_sel) &gt; 0:
                ax.plot(x_sel[-1], y_sel[-1], c=color_dict[cl], alpha=alpha, **dot_kwargs)
            if len(x_sel) &gt; 0:
                alpha -= alpha_decay
        
        # define the values for our legend
        color_dict = {key:val for key, val in color_dict.items() if key in segments[1]}
       
    # define legend artists
    leg_artists = [plt.Line2D((0,1),(0,0), color=color) for color in color_dict.values()]
    leg_indicators = list(color_dict.keys())
          
    if show_legend:
        ax.legend(leg_artists, leg_indicators)
                
    return ax</code></pre>
</details>
</dd>
<dt id="cateye.visualization.plot_nslr_segmentation"><code class="name flex">
<span>def <span class="ident">plot_nslr_segmentation</span></span>(<span>time_array, gaze_array, segmentation, seg_class, trial_info=None, title=None, stimulus=None, figsize=None, blinks=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a segmentation using NSLR's original segmentation (including smoothing). Not
intended for general use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_nslr_segmentation(time_array, gaze_array, segmentation, seg_class, trial_info=None,
                           title=None, stimulus=None, figsize=None, blinks=None):
    &#34;&#34;&#34;Plots a segmentation using NSLR&#39;s original segmentation (including smoothing). Not
    intended for general use.
    &#34;&#34;&#34;
    VAR_NAMES = [&#34;Theta&#34;, &#34;Phi&#34;]
    
    f, axes = plt.subplots(2, 1, sharex=True, figsize=figsize)
    f.subplots_adjust(hspace=0)
    f.suptitle(title)  # , fontsize=16)

    # the limits are defined as 2 std devs from mean
    y_lims = np.array(gaze_array).std(axis=0) * 2

    for idx, ax in enumerate(axes):

        # construct a plotting frame
        ax.set_ylabel(VAR_NAMES[idx] + &#34;: Rot. in degrees&#34;)
        ax.set_ylim([-y_lims[idx], y_lims[idx]])
        ax.axhline(y=0, color=&#34;lightgray&#34;, linestyle=&#34;--&#34;)
        ax.axhline(y=-20, color=&#34;lightgray&#34;, linestyle=&#34;--&#34;)
        ax.axhline(y=20, color=&#34;lightgray&#34;, linestyle=&#34;--&#34;)


        ax.plot(time_array, gaze_array[:,idx], &#39;.&#39;)
        if not isinstance(stimulus, type(None)):
            st_id = [&#34;X_Position&#34;, &#34;Y_Position&#34;]
            ax.plot(stimulus[&#34;Timestamp&#34;].to_numpy(), stimulus[st_id[idx]].to_numpy(), &#34;--&#34;, color=&#34;lightblue&#34;)

        for i, seg in enumerate(segmentation.segments):
            cls = seg_class[i]
            if (seg.t[0] &gt; time_array[0]) and (seg.t[1] &lt; time_array[-1]): 
                ax.plot(seg.t, np.array(seg.x)[:, idx], color=COLORS[cls])

    if trial_info != None and len(trial_info) &gt; 0:
        y_pos = - y_lims[1] * 0.95  # min([i[0] for i in gaze_array])
        x_pos = (time_array[-1] - time_array[1]) / 150

        for key in trial_info:
            axes[0].axvline(x=float(key), linestyle=&#34;--&#34;)
            axes[1].axvline(x=float(key), linestyle=&#34;--&#34;)
            axes[1].text(float(key) + x_pos, y_pos,
                         &#34;Event: {}&#34;.format(trial_info[key]), rotation=90,
                         verticalalignment=&#39;bottom&#39;, color=&#39;#1f77b4&#39;)  #, weight=&#34;bold&#34;)

    
    leg_artists = [plt.Line2D((0,1),(0,0), marker=&#39;.&#39;, linestyle=&#39;&#39;)] + \
                  [plt.Line2D((0,1),(0,0), color=color) for color in COLORS.values()]
    leg_indicators = [&#34;Orig. Samples&#34;, &#34;Fixation&#34;, &#34;Saccade&#34;, &#34;Smooth Pursuit&#34;, &#34;PSO&#34;]
    plt.legend(leg_artists, leg_indicators, loc=&#34;lower right&#34;, title=&#34;Gaze Classification&#34;)
    
        
    if not isinstance(stimulus, type(None)):
        leg_artists = leg_artists + [plt.Line2D((0,1),(0,0),  linestyle=&#39;--&#39;, color=&#34;lightblue&#34;)]
        leg_indicators = leg_indicators + [&#34;Stimulus data&#34;]
        
    plt.legend(leg_artists, leg_indicators, loc=&#34;lower right&#34;, title=&#34;Gaze Classification&#34;)
    plt.xlabel(&#34;Time in seconds&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cateye" href="index.html">cateye</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cateye.visualization.plot_segmentation" href="#cateye.visualization.plot_segmentation">plot_segmentation</a></code></li>
<li><code><a title="cateye.visualization.plot_trajectory" href="#cateye.visualization.plot_trajectory">plot_trajectory</a></code></li>
<li><code><a title="cateye.visualization.plot_nslr_segmentation" href="#cateye.visualization.plot_nslr_segmentation">plot_nslr_segmentation</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>